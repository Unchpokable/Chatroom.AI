#pragma once

#ifndef TTS_ONNX_H
#define TTS_ONNX_H

namespace tts::onnx
{
constexpr std::int32_t SHERPA_CONTINUE = 1;
constexpr std::int32_t SHERPA_STOP = 0;
} // namespace tts::onnx

namespace tts::onnx
{
using TtsGenerationProgressCallback = std::function<std::int32_t(std::span<const float> samples, std::int32_t samplerate, float progress)>;
} // namespace tts::onnx

namespace tts::onnx
{
struct TtsEngine {
    TtsEngine(const sherpa_onnx::cxx::OfflineTtsConfig& config, sherpa_onnx::cxx::OfflineTts&& engine, std::string lang)
        : config(config), engine(std::move(engine)), lang(std::move(lang))
    {
    }

    TtsEngine() = delete;
    TtsEngine(const TtsEngine&) = delete;
    TtsEngine& operator=(const TtsEngine&) = delete;

    TtsEngine(TtsEngine&&);
    TtsEngine& operator=(TtsEngine&&);

    sherpa_onnx::cxx::OfflineTtsConfig config;
    sherpa_onnx::cxx::OfflineTts engine;
    std::string lang;

    std::mutex mutex;
};

struct TtsEngineView {
    std::string_view model_name;
    const TtsEngine& engine;
};

} // namespace tts::onnx

namespace tts::onnx
{
extern std::uint8_t threads_count;
} // namespace tts::onnx

namespace tts::onnx
{
void configure_tts_threads_count(std::uint8_t threads_count);
} // namespace tts::onnx

namespace tts::onnx
{
void setup_config(std::string_view model_name,
    std::string_view model_path,
    std::string_view tokens_path,
    std::string_view lang_key,
    std::string_view provider = "cpu");
} // namespace tts::onnx

namespace tts::onnx
{
sherpa_onnx::cxx::Wave say(std::string_view model_name, std::string_view text, std::uint32_t samplerate);

// DOES NOT SUPPORT RESAMPLING. Generated audio will be sent as-is as it generated by model. If you want resampling, use blocking
// synchronous tts::onnx::say instead
void say_stream(std::string_view model_name, std::string_view text, TtsGenerationProgressCallback on_generated);
} // namespace tts::onnx

namespace tts::onnx
{
std::vector<tts::onnx::TtsEngineView> enumerate_models();
} // namespace tts::onnx

#endif